<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>5.3.3. Angle-tracking Phase-locked Loop (ATPLL) &#8212; MCAF R6 RC8 documentation (docver 6.0.2)</title>
    <link rel="stylesheet" href="../_static/microchip.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/mcaf_doc.css" />
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/svgcrop.js"></script>
    <script type="text/javascript" src="../_static/preliminary-draft.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js"></script>
    <script type="text/javascript" src="../_static/rendermath.js"></script>
    
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5.4. Flux control" href="flux_control/index.html" />
    <link rel="prev" title="5.3.2.3.4. Pullout torque method" href="qei_sync/pullout.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="flux_control/index.html" title="5.4. Flux control"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="qei_sync/pullout.html" title="5.3.2.3.4. Pullout torque method"
             accesskey="P">previous</a> |</li>
    <li><img class="nav-logo"
             src="../_static/Microchip-Logo-Horizontal-White-Red-120x28.png" alt=""
        /></li>
    <li><a href=""></a> &#187;</li>
    <a href="../index.html">MCAF R6 RC8 (docver 6.0.2)</a> &#187;
    
          <li class="nav-item nav-item-1"><a href="index.html" >5. Detailed Algorithm Notes</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="estimators.html" accesskey="U">5.3. Position and Velocity Estimation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="angle-tracking-phase-locked-loop-atpll">
<span id="algorithm-atpll"></span><span id="index-0"></span><h1>5.3.3. Angle-tracking Phase-locked Loop (ATPLL)<a class="headerlink" href="#angle-tracking-phase-locked-loop-atpll" title="Permalink to this headline">¶</a></h1>
<div class="section" id="overview">
<h2>5.3.3.1. Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p>The Angle-tracking Phase-locked Loop (ATPLL) is a velocity and rotor angle estimation algorithm provided for sensorless
closed-loop velocity control of a <a class="reference internal" href="../appendix/glossary.html#term-pmsm"><span class="xref std std-term">PMSM</span></a>. The algorithm has a <a class="reference internal" href="../appendix/glossary.html#term-pll"><span class="xref std std-term">PLL</span></a>-like structure, and it estimates the correct rotor
velocity and angle by making the d-axis component of the back emf equal to zero in steady state. The rotor velocity and angle
errors are eliminated in steady state due to a PI controller module included in the structure of the ATPLL estimator. The
ATPLL estimator algorithm can be used for the estimation of rotor velocity and rotor angle for PMSM motors with or without
rotor saliency.</p>
</div>
<div class="section" id="implementation-block-diagram-and-description">
<h2>5.3.3.2. Implementation Block Diagram and Description<a class="headerlink" href="#implementation-block-diagram-and-description" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#fig-atpll-generic"><span class="std std-numref">Figure 5.51</span></a> shows the basic principle of the ATPLL estimator. Here, The outputs of the
estimator are estimated rotor velocity (<span class="math">\(\hat\omega\)</span>) and estimated rotor angle (<span class="math">\(\hat\theta\)</span>).
The d-axis component (<span class="math">\(E_d\)</span>) of the back-emf is calculated from the motor stator voltages
(<span class="math">\(V_{\alpha}\)</span>, <span class="math">\(V_{\beta}\)</span>) and stator currents (<span class="math">\(I_{\alpha}\)</span>, <span class="math">\(I_{\beta}\)</span>).
The reference value of <span class="math">\(E_d\)</span> is zero, therefore the error becomes equal to <span class="math">\(- E_d\)</span>. This
error is fed to a PI controller. The output of the PI controller is added with a feedforward velocity term
<span class="math">\(\omega_{ref}\)</span>, and this addition is the estimated velocity <span class="math">\(\hat\omega\)</span>. The estimated velocity
is integrated to obtain the estimated rotor angle <span class="math">\(\hat\theta\)</span>.</p>
<div class="figure align-center" id="id1">
<span id="fig-atpll-generic"></span><a class="reference internal image-reference" href="../_images/atpll_generic.png"><img alt="../_images/atpll_generic.png" src="../_images/atpll_generic.png" style="width: 500px; height: 212px;" /></a>
<div class="caption_wrapper"><p class="caption"><span class="caption-number">Figure 5.51 </span><span class="caption-text">ATPLL: Generic Block Diagram</span></p>
</div></div>
<p>The MCAF implementation of the ATPLL estimator is shown in <a class="reference internal" href="#fig-atpll-impl"><span class="std std-numref">Figure 5.52</span></a>. A brief description of the
different blocks used in the ATPLL structure is given below.</p>
<div class="figure align-center" id="id2">
<span id="fig-atpll-impl"></span><img alt="../_images/atpll.png" src="../_images/atpll.png" />
<div class="caption_wrapper"><p class="caption"><span class="caption-number">Figure 5.52 </span><span class="caption-text">ATPLL implementation</span></p>
</div></div>
<ul class="simple">
<li>Inputs: The ATPLL algorithm begins by calculating the back-emf components <span class="math">\(E_{\alpha}\)</span> and <span class="math">\(E_{\beta}\)</span>
from the stator voltages (<span class="math">\(V_{\alpha}\)</span>, <span class="math">\(V_{\beta}\)</span>) and stator currents (<span class="math">\(I_{\alpha}\)</span>,
<span class="math">\(I_{\beta}\)</span>) using the motor resistance and inductance values. These back-emf values are then used for further
calculation of <span class="math">\(- E_d\)</span> as shown in <a class="reference internal" href="#fig-atpll-impl"><span class="std std-numref">Figure 5.52</span></a>. For calculation of <span class="math">\(E_{\alpha}\)</span> and <span class="math">\(E_{\beta}\)</span>,
equation <a class="reference internal" href="#equation-eq-bemf-nonsalient">5.27</a> is used for motors without significant rotor saliency, and equation <a class="reference internal" href="#equation-eq-bemf-salient">5.28</a> is
used for motors with rotor saliency. Motors are categorised into those with and without significant rotor saliency based on
their <a class="reference internal" href="#atpll-saliency"><span class="std std-ref">Saliency Constant</span></a>. In <a class="reference internal" href="#equation-eq-bemf-nonsalient">5.27</a>, <span class="math">\(R_{s}\)</span> and <span class="math">\(L_{s}\)</span> are per-phase
stator winding resistance and inductance values respectively. In <a class="reference internal" href="#equation-eq-bemf-salient">5.28</a>, <span class="math">\(\theta\)</span> is the rotor angle and
<span class="math">\(L_0\)</span> and <span class="math">\(L_1\)</span> are given by <a class="reference internal" href="#equation-l0l1">5.29</a>.</li>
</ul>
<div class="math" id="equation-eq-bemf-nonsalient">
<span class="eqno">(5.27)</span>\[\begin{bmatrix} E_{\alpha} \\ E_{\beta} \end{bmatrix} = \begin{bmatrix} V_{\alpha} \\ V_{\beta} \end{bmatrix} -
\begin{bmatrix} R_{s} &amp; 0 \\ 0 &amp; R_{s} \end{bmatrix} \begin{bmatrix} I_{\alpha} \\ I_{\beta} \end{bmatrix} -
\begin{bmatrix} L_{s} &amp; 0 \\ 0 &amp; L_{s} \end{bmatrix} \frac{d}{dt}\begin{bmatrix} I_{\alpha} \\ I_{\beta} \end{bmatrix}\]</div>
<div class="math" id="equation-eq-bemf-salient">
<span class="eqno">(5.28)</span>\[\begin{bmatrix} E_{\alpha} \\ E_{\beta} \end{bmatrix} = \begin{bmatrix} V_{\alpha} \\ V_{\beta} \end{bmatrix} -
\begin{bmatrix} R_{s} &amp; 0 \\ 0 &amp; R_{s} \end{bmatrix} \begin{bmatrix} I_{\alpha} \\ I_{\beta} \end{bmatrix} -
\frac{d}{dt}\begin{bmatrix}\begin{bmatrix} L_{0}+L_{1}\cos 2\theta &amp; L_{1}\sin 2\theta \\ L_{1}\sin 2\theta &amp; L_{0}-L_{1}\cos 2\theta \end{bmatrix} \begin{bmatrix} I_{\alpha} \\ I_{\beta} \end{bmatrix} \end{bmatrix}\]</div>
<div class="math" id="equation-l0l1">
<span class="eqno">(5.29)</span>\[L_0 = \frac{L_d + L_q}{2},  L_1 = \frac{L_d - L_q}{2}\]</div>
<ul class="simple">
<li>Two-point Averaging: As mentioned above, first <span class="math">\(- E_d\)</span> is calculated from <span class="math">\(E_{\alpha}\)</span> and <span class="math">\(E_{\beta}\)</span>
and is fed to the Two-point Averaging block. This block helps to smooth the input to the Proportional-Integral (PI)
controller (<span class="math">\(G_{PI}(s)\)</span>).</li>
<li><span class="math">\(G_{PI}(s)\)</span> : This block represents a PI controller which is the backbone of the ATPLL estimator. In steady state, the
input to the PI controller (which is: <span class="math">\(- E_d\)</span>) is reduced to zero, thereby reducing the steady-state error in the estimated
velocity and angle to zero as well. The s-domain representation of <span class="math">\(G_{PI}(s)\)</span> is as given below:</li>
</ul>
<div class="math" id="equation-algorithms-atpll-0">
<span class="eqno">(5.30)</span>\[G_{PI}(s) = K_p + \frac{K_i}{s}

\]</div>
<ul class="simple">
<li><span class="math">\(G_{Filt1}(s)\)</span> : This is a low-pass filter at the output of the PI controller. After filtering, the output is added to
the reference velocity (<span class="math">\(\omega_{ref}\)</span>). The result of this addition is the unfiltered estimated velocity and is
integrated to calculate the estimated rotor angle (<span class="math">\(\hat\theta\)</span>). The s-domain representation of <span class="math">\(G_{Filt1}(s)\)</span> is
as given below, where, <span class="math">\(\tau_1\)</span> is the filter time constant.</li>
</ul>
<div class="math" id="equation-algorithms-atpll-1">
<span class="eqno">(5.31)</span>\[G_{Filt1}(s) = \frac{1}{\tau_1 s + 1}

\]</div>
<ul class="simple">
<li><span class="math">\(G_{Filt2}(s)\)</span> : The result of the addition of the PI controller output and the reference velocity is further filtered
using this low-pass filter. The output of this filter is the estimated rotor velocity (<span class="math">\(\hat\omega\)</span>). The s-domain
representation of <span class="math">\(G_{Filt2}(s)\)</span> is as given below, where, <span class="math">\(\tau_2\)</span> is the filter time constant.</li>
</ul>
<div class="math" id="equation-algorithms-atpll-2">
<span class="eqno">(5.32)</span>\[G_{Filt2}(s) = \frac{1}{\tau_2 s + 1}

\]</div>
<p>Following are some important points related to the PI controller and low-pass filter blocks.</p>
<ul class="simple">
<li>To obtain a stable dynamic performance of the ATPLL estimator over the entire operating velocity range, the
integral gain <span class="math">\(K_i\)</span> is made dependent on the reference velocity <span class="math">\(\omega_{ref}\)</span>.
To support motors with different parameter values, the proportional
and integral gains <span class="math">\(K_p\)</span> and <span class="math">\(K_i\)</span> are made dependent on the motor’s back-emf constant <span class="math">\(K_e\)</span>.
Empirical tuning of the PI controller gains simplifies the design significantly.
The empirical equations for <span class="math">\(K_p\)</span> and <span class="math">\(K_i\)</span> are given in equation <a class="reference internal" href="#equation-eqn-atpll-pi-gains">5.33</a>.</li>
</ul>
<div class="math" id="equation-eqn-atpll-pi-gains">
<span class="eqno">(5.33)</span>\[\begin{aligned}
K_{p} &amp;= \frac{1.9}{K_e} \cr
K_{i} &amp;= \frac{\omega_{ref}}{30 K_e}
\end{aligned}\]</div>
<ul class="simple">
<li>Reversal of velocity is supported by the ATPLL estimator. In order to make this possible, the signs of PI
controller gains are reversed based on the sign of the reference velocity.</li>
<li>Filter constants <span class="math">\(\tau_1\)</span> and <span class="math">\(\tau_2\)</span> are decided based on the performance of the control
algorithm for a range of motors. The filter constants are fixed in MCAF R5, but may be made adjustable in
a future revision.</li>
</ul>
</div>
<div class="section" id="application-to-pmsms-with-saliency">
<span id="atpll-saliency"></span><h2>5.3.3.3. Application to PMSMs with Saliency<a class="headerlink" href="#application-to-pmsms-with-saliency" title="Permalink to this headline">¶</a></h2>
<p>In case of interior permanent-magnet motors (IPMSMs), the <span class="math">\(d\)</span>- and <span class="math">\(q\)</span>-axis
inductances are not equal; typically
<span class="math">\(L_q\)</span> is larger than <span class="math">\(L_d\)</span>. In order to quantify the degree of saliency in the rotor, the
following saliency constant is defined. Here, <span class="math">\(\xi\)</span> is equal to <span class="math">\(\frac{L_q}{L_d}\)</span>.</p>
<div class="math" id="equation-algorithms-atpll-3">
<span class="eqno">(5.34)</span>\[\text{Saliency Constant} = 1 - \frac{1}{\xi}

\]</div>
<p>It can be noted that the saliency constant is equal to 0 for motors with no saliency and increases toward 1 as the
saliency increases. For a correct rotor velocity and angle estimation, it is important that the relevant
equations are used by the estimator, which are different for motors with salient and non-salient rotors. In
order to differentiate the salient motors from the non-salient ones, a saliency constant threshold of 0.25 is
defined. Thus, the motors satisfying the following condition are considered to be salient pole motors.</p>
<div class="math" id="equation-algorithms-atpll-4">
<span class="eqno">(5.35)</span>\[1 - \frac{1}{\xi} &gt; 0.25

\]</div>
<p>This can further be simplified to</p>
<div class="math" id="equation-algorithms-atpll-5">
<span class="eqno">(5.36)</span>\[\xi &gt; \frac{4}{3}.

\]</div>
<p>The ATPLL estimator accommodates motors both with salient and non-salient rotors by a suitable choice of equations in its
algorithm, thus preserving the accuracy of rotor velocity and angle estimation.</p>
</div>
<div class="section" id="sample-results">
<h2>5.3.3.4. Sample Results<a class="headerlink" href="#sample-results" title="Permalink to this headline">¶</a></h2>
<p>The following results are obtained from numerical simulation for a Leadshine 400 motor. A superimposed
plot of actual rotor velocity and the estimated rotor velocity by the ATPLL estimator is shown in
<a class="reference internal" href="#fig-atpll-speed"><span class="std std-numref">Figure 5.53</span></a> along with the plot showing the error in estimated velocity. It can be observed
that the steady-state velocity error is zero.</p>
<div class="figure align-center" id="id3">
<span id="fig-atpll-speed"></span><a class="reference internal image-reference" href="../_images/atpll_speed_error.png"><img alt="../_images/atpll_speed_error.png" src="../_images/atpll_speed_error.png" style="width: 560.0px; height: 420.0px;" /></a>
<div class="caption_wrapper"><p class="caption"><span class="caption-number">Figure 5.53 </span><span class="caption-text">Estimated Rotor Velocity by the ATPLL</span></p>
</div></div>
<p>A superimposed plot of actual rotor angle and the estimated rotor angle by ATPLL estimator along with
the error in the estimated angle is shown in <a class="reference internal" href="#fig-atpll-angle"><span class="std std-numref">Figure 5.54</span></a>. This plot is for the same velocity
transient shown in <a class="reference internal" href="#fig-atpll-speed"><span class="std std-numref">Figure 5.53</span></a>. It can be seen that the steady-state angle error is zero.</p>
<div class="figure align-center" id="id4">
<span id="fig-atpll-angle"></span><a class="reference internal image-reference" href="../_images/atpll_angle_error.png"><img alt="../_images/atpll_angle_error.png" src="../_images/atpll_angle_error.png" style="width: 560.0px; height: 420.0px;" /></a>
<div class="caption_wrapper"><p class="caption"><span class="caption-number">Figure 5.54 </span><span class="caption-text">Estimated Rotor Angle by the ATPLL</span></p>
</div></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.3.3. Angle-tracking Phase-locked Loop (ATPLL)</a><ul>
<li><a class="reference internal" href="#overview">5.3.3.1. Overview</a></li>
<li><a class="reference internal" href="#implementation-block-diagram-and-description">5.3.3.2. Implementation Block Diagram and Description</a></li>
<li><a class="reference internal" href="#application-to-pmsms-with-saliency">5.3.3.3. Application to PMSMs with Saliency</a></li>
<li><a class="reference internal" href="#sample-results">5.3.3.4. Sample Results</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="qei_sync/pullout.html"
                        title="previous chapter">5.3.2.3.4. Pullout torque method</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="flux_control/index.html"
                        title="next chapter">5.4. Flux control</a></p>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="flux_control/index.html" title="5.4. Flux control"
             >next</a> |</li>
        <li class="right" >
          <a href="qei_sync/pullout.html" title="5.3.2.3.4. Pullout torque method"
             >previous</a> |</li>
    <li><img class="nav-logo"
             src="../_static/Microchip-Logo-Horizontal-White-Red-120x28.png" alt=""
        /></li>
    <li><a href=""></a> &#187;</li>
    <a href="../index.html">MCAF R6 RC8 (docver 6.0.2)</a> &#187;
    
          <li class="nav-item nav-item-1"><a href="index.html" >5. Detailed Algorithm Notes</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="estimators.html" >5.3. Position and Velocity Estimation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017-2020, Microchip Technology, Inc..
    </div>
  </body>
</html>